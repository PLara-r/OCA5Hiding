# OCA5Hiding

Скрытие статических методов
Скрытый метод возникает , когда дочерний класс определяет статический метод с тем же именем и сигнатурой как метод статического , определенным в родительском классе.
Сокрытие метода похоже, но не точно так же, как переопределение метода. Во-первых, четыре предыдущих правила для переопределения метода должны соблюдаться, когда метод скрыт.
Кроме того, добавлено новое правило для сокрытия метода, а именно, что использование staticключевого слова должно быть одинаковым для родительских и дочерних классов.
В следующем списке приведены пять правил скрытия метода:
1.	Метод в дочернем классе должен иметь ту же сигнатуру, что и метод в родительском классе.
2.	Метод в дочернем классе должен быть по крайней мере таким же доступным или более доступным, как метод в родительском классе.
3.	Метод в дочернем классе не может выдавать проверенное исключение, которое является новым или более широким, чем класс любого исключения,
выданного в методе родительского класса.
4.	Если метод возвращает значение, оно должно быть тем же или подклассом метода в родительском классе, известном как ковариантные возвращаемые типы .
5.	Метод, определенный в дочернем классе, должен быть помечен, как staticесли бы он был отмечен как staticв родительском классе (скрытие метода). 
Аналогично, метод не должен быть помечен как staticв дочернем классе, если он не помечен как staticв родительском классе (переопределение метода).
Обратите внимание, что первые четыре соответствуют правилам переопределения метода.
Давайте рассмотрим несколько примеров нового правила:

public class Bear { 
 public static void eat() {  
  System.out.println("Bear is eating");
  }}
public class Panda extends Bear {
  public static void eat() {  
  System.out.println("Panda bear is chewing");
  }  
public static void main(String[] args) { 
   Panda.eat(); 
 }}
В этом примере код компилируется и запускается без проблем. eat()Метод в дочернем классе скрывает eat()метод родительского класса.
Поскольку они оба помечены как static, это не считается переопределенным методом. Давайте сопоставим это с примерами, которые нарушают пятое правило:

public class Bear { 
 public static void sneeze() { 
   System.out.println("Bear is sneezing");
  } 
 public void hibernate() { 
   System.out.println("Bear is hibernating"); 
 }}
public class Panda extends Bear { 
 public void sneeze() {  // DOES NOT COMPILE  
  System.out.println("Panda bear sneezes quietly"); 
 }
  public static void hibernate() {  // DOES NOT COMPILE
    System.out.println("Panda bear is going to sleep"); 
 }}
В этом примере sneeze()помечается как staticв родительском классе, но не в дочернем классе.
Компилятор обнаруживает, что вы пытаетесь переопределить метод, который должен быть скрыт, и генерирует ошибку компилятора.
Во втором методе hibernate()это член экземпляра в родительском классе, но статический метод в дочернем классе. В этом случае компилятор думает, 
что вы пытаетесь скрыть метод, который должен быть переопределен, и также генерирует ошибку компилятора.
Как вы видели в предыдущем примере, скрытие статических методов чревато подводными камнями и потенциальными проблемами,
поэтому их следует избегать. Хотя вы можете увидеть на экзамене вопросы, содержащие скрытые статические методы, которые синтаксически верны,
избегайте скрывать статические методы в своей работе, так как это может привести к запутанному и трудно читаемому коду.
Вы не должны повторно использовать имя статического метода в вашем классе, если оно уже используется в родительском классе.
Переопределение или сокрытие методов
В нашем описании сокрытия статических методов мы указали, что существует различие между переопределением и скрытием методов.
В отличие от переопределения метода, в котором дочерний метод заменяет родительский метод в вызовах, определенных как в родительском,
так и в дочернем методах, скрытые методы заменяют только родительские методы в вызовах, определенных в дочернем классе.
Во время выполнения дочерняя версия переопределенного метода всегда выполняется для экземпляра независимо от того, 
определен ли вызов метода в методе родительского или дочернего класса. Таким образом, родительский метод никогда не используется, 
если на него не ссылается явный вызов родительского метода с использованием синтаксиса ParentClassName.method(). Кроме того,
во время выполнения родительская версия скрытого метода всегда выполняется, если вызов метода определен в родительском классе. Давайте посмотрим на пример:

public class Marsupial { 
 public static boolean isBiped() {  
  return false;
  }  
public void getMarsupialDescription() { 
   System.out.println("Marsupial walks on two legs: "+isBiped());
  }}
public class Kangaroo extends Marsupial {
  public static boolean isBiped() {  
  return true; 
 } 
 public void getKangarooDescription() { 
   System.out.println("Kangaroo hops on two legs: "+isBiped());
  }  
public static void main(String[] args) { 
   Kangaroo joey = new Kangaroo();  
  joey.getMarsupialDescription();  
  joey.getKangarooDescription();  
}}
В этом примере код компилируется и запускается без проблем, выводя следующее:

Marsupial walks on two legs: false
Kangaroo hops on two legs: true
Обратите внимание, что isBiped()возвращается falseв родительский класс и trueв дочерний класс.
В первом вызове метода getMarsupialDescription()используется родительский метод . 
MarsupialКласс знает только isBiped()из своего собственного определения класса, так что он выводит false. Во втором вызове метода дочерний объект выполняет метод isBiped(), 
который скрывает версию родительского метода и возвращает true.
Сравните этот первый пример со следующим примером, в котором isBiped()вместо скрытой версии используется переопределенная версия:

class Marsupial { 
 public boolean isBiped() { 
   return false; 
 }
  public void getMarsupialDescription() {   
 System.out.println("Marsupial walks on two legs: "+isBiped());
  }}
public class Kangaroo extends Marsupial { 
 public boolean isBiped() { 
   return true;
  }
  public void getKangarooDescription() {    
System.out.println("Kangaroo hops on two legs: "+isBiped());
  }
  public static void main(String[] args) { 
   Kangaroo joey = new Kangaroo();  
  joey.getMarsupialDescription();  
  joey.getKangarooDescription();
  }}
Этот код также компилируется и запускается без проблем, но выводит немного другой текст:

Marsupial walks on two legs: true
Kangaroo hops on two legs: true

В этом примере isBiped()метод переопределяется, а не скрывается в дочернем классе. Следовательно, он заменяется во время выполнения в
родительском классе вызовом метода дочернего класса.
Убедитесь, что вы понимаете эти примеры, поскольку они показывают, как скрытые и переопределенные методы принципиально отличаются. 
Этот пример использует полиморфизм



Наследование переменных

Как вы видели с переопределением методов, было много правил, когда два метода имеют одинаковую сигнатуру и определены как в родительском, так и в дочернем классах. К счастью, правила для переменных с одинаковыми именами в родительском и дочернем классах намного проще, потому что Java не позволяет переменным быть переопределенными, а вместо этого скрытыми.


Сокрытие переменных

Когда вы скрываете переменную, вы определяете переменную с тем же именем, что и переменная в родительском классе. Это создает две копии переменной
в экземпляре дочернего класса: один экземпляр, определенный для родительской ссылки, а другой - для дочерней ссылки.
Как и при скрытии статического метода, вы не можете переопределить переменную; Вы можете только скрыть это. Также похоже на скрытие статического метода, правила доступа к родительским и дочерним переменным очень похожи. Если вы ссылаетесь на переменную из родительского класса, используется переменная, определенная в родительском классе. В качестве альтернативы, если вы ссылаетесь на переменную из дочернего класса, используется переменная, определенная в дочернем классе. Кроме того, вы можете ссылаться на родительское значение переменной с явным использованием superключевого слова. Рассмотрим следующий пример:

public class Rodent {  
protected int tailLength = 4; 
 public void getRodentDetails() {  
  System.out.println("[parentTail="+tailLength+"]")
  }}
public class Mouse extends Rodent { 
 protected int tailLength = 8;
  public void getMouseDetails(){  
  System.out.println("[tail="+tailLength +",parentTail="+super.tailLength+"]"); 
 } 
 public static void main(String[] args) { 
   Mouse mouse = new Mouse(); 
   mouse.getRodentDetails();  
  mouse.getMouseDetails();  
}}
Этот код компилируется без проблем и выводит следующее при выполнении:

[parentTail=4]
[tail=8,parentTail=4]
Обратите внимание, что экземпляр Mouseсодержит две копии tailLengthпеременных: одну, определенную в родительской, и одну, определенную в дочерней. Эти экземпляры хранятся отдельно друг от друга, что позволяет нашему экземпляру Mouseссылаться на оба tailLengthзначения независимо. При первом вызове метода getRodentDetails()родительский метод выводит родительское значение tailLengthпеременной. Во втором вызове метода getMouseDetails()дочерний метод выводит как дочернюю,
так и родительскую версию tailLengthпеременных, используя superключевое слово для доступа к значению родительской переменной.
Важно помнить, что нет понятия переопределения переменной-члена. Например, нет никакого изменения кода, которое могло бы быть сделано, чтобы заставить Java переопределить значение tailLength, делая его одинаковым как для родительского, так и для дочернего. Эти правила одинаковы независимо от того,
является ли переменная экземпляром переменной или статической переменной.


Не скрывайте переменные на практике

Хотя Java позволяет скрыть переменную, определенную в родительском классе, с переменной, определенной в дочернем классе, это считается крайне плохой практикой кодирования. Например, взгляните на следующий код, который использует скрытую переменную length, помеченную как publicв родительских, так и в дочерних классах.

public class Animal {  public int length = 2;}
public class Jellyfish extends Animal {
  public int length = 5; 
 public static void main(String[] args) {  
  Jellyfish jellyfish = new Jellyfish();  
  Animal animal = new Jellyfish();  
  System.out.println(jellyfish.length);   
 System.out.println(animal.length); 
 }}
Этот код компилируется без проблем. Вот вывод:

5
2
Обратите внимание, что один и тот же тип объекта был создан дважды, но ссылка на объект определяет, какое значение будет отображаться в качестве выходного. Если объект Jellyfishбыл передан методу по Animalссылке, как вы увидите в разделе «Понимание полиморфизма» далее в этой главе, может использоваться неправильное значение.
Скрытие переменных делает код очень запутанным и трудным для чтения, особенно если вы начинаете изменять значение переменной как в родительском, так и в дочернем методах, поскольку может быть неясно, какую переменную вы обновляете.
При определении новой переменной в классе ребенка, считается хорошей практикой кодирования , чтобы выбрать имя для переменной, которая уже не является public, protectedили переменная по умолчанию используется в родительском классе. Скрытие privateпеременных считается менее проблематичным,
поскольку у дочернего класса не было доступа к переменной в родительском классе с самого начала.

Создание окончательных методов

 finalметоды не могут быть переопределены. вы можете создать метод с finalключевым словом. Тем не менее, вы запрещаете дочернему классу переопределять этот метод. Это правило действует как при переопределении метода, так и при скрытии метода. Другими словами, вы не можете скрыть статический метод в родительском классе, если он помечен как final.


