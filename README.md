# OCA5Hiding

Скрытие статических методов
Скрытый метод возникает , когда дочерний класс определяет статический метод с тем же именем и сигнатурой как метод статического , определенным в родительском классе.
Сокрытие метода похоже, но не точно так же, как переопределение метода. Во-первых, четыре предыдущих правила для переопределения метода должны соблюдаться, когда метод скрыт.
Кроме того, добавлено новое правило для сокрытия метода, а именно, что использование staticключевого слова должно быть одинаковым для родительских и дочерних классов.
В следующем списке приведены пять правил скрытия метода:
1.	Метод в дочернем классе должен иметь ту же сигнатуру, что и метод в родительском классе.
2.	Метод в дочернем классе должен быть по крайней мере таким же доступным или более доступным, как метод в родительском классе.
3.	Метод в дочернем классе не может выдавать проверенное исключение, которое является новым или более широким, чем класс любого исключения,
выданного в методе родительского класса.
4.	Если метод возвращает значение, оно должно быть тем же или подклассом метода в родительском классе, известном как ковариантные возвращаемые типы .
5.	Метод, определенный в дочернем классе, должен быть помечен, как staticесли бы он был отмечен как staticв родительском классе (скрытие метода). 
Аналогично, метод не должен быть помечен как staticв дочернем классе, если он не помечен как staticв родительском классе (переопределение метода).
Обратите внимание, что первые четыре соответствуют правилам переопределения метода.
Давайте рассмотрим несколько примеров нового правила:

public class Bear { 
 public static void eat() {  
  System.out.println("Bear is eating");
  }}
public class Panda extends Bear {
  public static void eat() {  
  System.out.println("Panda bear is chewing");
  }  
public static void main(String[] args) { 
   Panda.eat(); 
 }}
В этом примере код компилируется и запускается без проблем. eat()Метод в дочернем классе скрывает eat()метод родительского класса.
Поскольку они оба помечены как static, это не считается переопределенным методом. Давайте сопоставим это с примерами, которые нарушают пятое правило:

public class Bear { 
 public static void sneeze() { 
   System.out.println("Bear is sneezing");
  } 
 public void hibernate() { 
   System.out.println("Bear is hibernating"); 
 }}
public class Panda extends Bear { 
 public void sneeze() {  // DOES NOT COMPILE  
  System.out.println("Panda bear sneezes quietly"); 
 }
  public static void hibernate() {  // DOES NOT COMPILE
    System.out.println("Panda bear is going to sleep"); 
 }}
В этом примере sneeze()помечается как staticв родительском классе, но не в дочернем классе.
Компилятор обнаруживает, что вы пытаетесь переопределить метод, который должен быть скрыт, и генерирует ошибку компилятора.
Во втором методе hibernate()это член экземпляра в родительском классе, но статический метод в дочернем классе. В этом случае компилятор думает, 
что вы пытаетесь скрыть метод, который должен быть переопределен, и также генерирует ошибку компилятора.
Как вы видели в предыдущем примере, скрытие статических методов чревато подводными камнями и потенциальными проблемами,
поэтому их следует избегать. Хотя вы можете увидеть на экзамене вопросы, содержащие скрытые статические методы, которые синтаксически верны,
избегайте скрывать статические методы в своей работе, так как это может привести к запутанному и трудно читаемому коду.
Вы не должны повторно использовать имя статического метода в вашем классе, если оно уже используется в родительском классе.
Переопределение или сокрытие методов
В нашем описании сокрытия статических методов мы указали, что существует различие между переопределением и скрытием методов.
В отличие от переопределения метода, в котором дочерний метод заменяет родительский метод в вызовах, определенных как в родительском,
так и в дочернем методах, скрытые методы заменяют только родительские методы в вызовах, определенных в дочернем классе.
Во время выполнения дочерняя версия переопределенного метода всегда выполняется для экземпляра независимо от того, 
определен ли вызов метода в методе родительского или дочернего класса. Таким образом, родительский метод никогда не используется, 
если на него не ссылается явный вызов родительского метода с использованием синтаксиса ParentClassName.method(). Кроме того,
во время выполнения родительская версия скрытого метода всегда выполняется, если вызов метода определен в родительском классе. Давайте посмотрим на пример:

public class Marsupial { 
 public static boolean isBiped() {  
  return false;
  }  
public void getMarsupialDescription() { 
   System.out.println("Marsupial walks on two legs: "+isBiped());
  }}
public class Kangaroo extends Marsupial {
  public static boolean isBiped() {  
  return true; 
 } 
 public void getKangarooDescription() { 
   System.out.println("Kangaroo hops on two legs: "+isBiped());
  }  
public static void main(String[] args) { 
   Kangaroo joey = new Kangaroo();  
  joey.getMarsupialDescription();  
  joey.getKangarooDescription();  
}}
В этом примере код компилируется и запускается без проблем, выводя следующее:

Marsupial walks on two legs: false
Kangaroo hops on two legs: true
Обратите внимание, что isBiped()возвращается falseв родительский класс и trueв дочерний класс.
В первом вызове метода getMarsupialDescription()используется родительский метод . 
MarsupialКласс знает только isBiped()из своего собственного определения класса, так что он выводит false. Во втором вызове метода дочерний объект выполняет метод isBiped(), 
который скрывает версию родительского метода и возвращает true.
Сравните этот первый пример со следующим примером, в котором isBiped()вместо скрытой версии используется переопределенная версия:

class Marsupial { 
 public boolean isBiped() { 
   return false; 
 }
  public void getMarsupialDescription() {   
 System.out.println("Marsupial walks on two legs: "+isBiped());
  }}
public class Kangaroo extends Marsupial { 
 public boolean isBiped() { 
   return true;
  }
  public void getKangarooDescription() {    
System.out.println("Kangaroo hops on two legs: "+isBiped());
  }
  public static void main(String[] args) { 
   Kangaroo joey = new Kangaroo();  
  joey.getMarsupialDescription();  
  joey.getKangarooDescription();
  }}
Этот код также компилируется и запускается без проблем, но выводит немного другой текст:

Marsupial walks on two legs: true
Kangaroo hops on two legs: true

В этом примере isBiped()метод переопределяется, а не скрывается в дочернем классе. Следовательно, он заменяется во время выполнения в
родительском классе вызовом метода дочернего класса.
Убедитесь, что вы понимаете эти примеры, поскольку они показывают, как скрытые и переопределенные методы принципиально отличаются. 
Этот пример использует полиморфизм
